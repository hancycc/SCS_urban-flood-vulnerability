import matplotlib
import pandas as pd
import numpy as np
import shap
from matplotlib import pyplot as plt
from matplotlib.colors import ListedColormap
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
import seaborn.palettes as sns_palettes
from tqdm import tqdm  # 导入 tqdm
import seaborn as sns

# 1. 从CSV文件加载数据
col_names = ['AI', 'Elevation', 'FVC', 'ISP', 'lithology', 'LULC', 'Preciptation', 'SHDI', 'slope', 'SWR', 'F', 'F1', 'RE_F']
data = pd.read_csv(r'C:\Users\A\Desktop\公管_返修\数据_new\Ori_n_re.csv', header=None, names=col_names)
datan = data.sample(n=15000)
data_sample = data.sample(n=2000)  # random_state=132
data_sample.to_csv('random_count_rf.csv')
# 分离特征和目标
X = data_sample.iloc[:, [0, 1, 3, 4, 5, 6, 7, 8, 9]]
x = datan.iloc[:, [0, 1, 3, 4, 5, 6, 7, 8, 9]]
y = data_sample.iloc[:, 11]
print("1")
# 2. 将数据分为训练集和测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)
print("1")
# 3. 构建随机森林模型
ntree = 500
mtry = 3  # 试过 最好

RFModel = RandomForestRegressor(n_estimators=ntree, max_features=mtry, max_depth=5)  #

# 使用 tqdm 包装循环以添加进度条
with tqdm(total=ntree, desc="Training Random Forest") as pbar:
    for i in range(ntree):
        # 在每次迭代之后更新进度条
        pbar.update(1)
        # 你的训练代码
        RFModel.fit(X_train, y_train)
pbar.close()  # 训练完成后关闭进度条
print("Random Forest model trained")

# 4. 评估模型精度
y_pred = RFModel.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

explainer = shap.TreeExplainer(RFModel)
# shap_values = explainer.shap_values(x)
# shap_values = explainer(X)
shap_values = explainer.shap_values(X)
shap_values_all = explainer(x)

# shap_values_all = explainer.shap_values(x)

# 将 SHAP 值保存为 DataFrame,保存 DataFrame 到 CSV 文件
shap_df = pd.DataFrame(shap_values, columns=X.columns)
shap_df.to_csv('shap_values_rf.csv', index=False)
# shap_df_all = pd.DataFrame(shap_values_all, columns=x.columns)
# shap_df_all.to_csv('shap_values_all.csv', index=False)

# 任选一段颜色
cmap = plt.get_cmap('YlOrRd')
# 创建一个从 'summer_r' 颜色梯度的 0.1 位置开始到 1 的颜色列表
colors = cmap(np.linspace(0.2, 1, 256))
# 使用颜色列表创建新的颜色梯度 'summer_r_plus'
summer_r_plus = matplotlib.colors.LinearSegmentedColormap.from_list('summer_r_plus', colors)
plt.figure()
shap.plots.beeswarm(shap_values_all, color=summer_r_plus)
plt.show()

# # 单点依赖图
shap.plots.waterfall(shap_values[2456143])

# # 全局重要性图
# plt.figure()
# shap.summary_plot(shap_values, X_train, plot_type="bar")
# plt.savefig('shap_all_bar.png')  # 将图保存为文件
# plt.show()  # 显示图形窗口

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")


