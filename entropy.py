import numpy as np
import pandas as pd
import math
from tqdm import tqdm


# 定义熵值法函数
def cal_weight(x):
    # 标准化
    x = x.apply(lambda x: ((x - np.min(x)) / (np.max(x) - np.min(x))))

    # k值
    rows = x.index.size  # 行值
    cols = x.columns.size  # 列值
    k = 1.0 / math.log(rows)
    inf = [[None] * cols for i in range(rows)]

    # 矩阵计算 、信息熵
    x = np.array(x)
    inf = [[None] * cols for i in range(rows)]
    inf = np.array(inf)
    for i in range(0, rows):
        for j in range(0, cols):
            if x[i][j] == 0:
                infij = 0
            else:
                p = x[i][j] / x.sum(axis=0)[j]
                infij = math.log(p) * p * (-k)
            inf[i][j] = infij
    inf = pd.DataFrame(inf)
    E = inf

    # 计算冗余度
    d = 1 - E.sum(axis=0)
    # 计算各指标的权重
    w = [[None] * 1 for i in range(cols)]
    for j in range(0, cols):
        wj = d[j] / sum(d)
        w[j] = wj
        # 计算各样本的综合得分,用最原始的数据

    w = pd.DataFrame(w)
    return w


if __name__ == '__main__':
    df = pd.read_csv(r"C:\Users\A\Desktop\城市韧性计算\gz\out_gz_tif.csv")
    # df = df.iloc[:, 1:100]
    # df = df.drop(["FID", "Id"], axis=1)
    # 计算df各字段的权重
    w = cal_weight(df)  # 调用cal_weight
    w.index = df.columns
    w.columns = ['weight']
    print(w)
    print('运行完成!')

